name: Create PR from Comment

on:
  issue_comment:
    types: [edited]

jobs:
  create-pr:
    name: Create PR from Comment
    runs-on: ubuntu-latest
    if: contains(github.event.comment.body, 'Create PR')
    
    permissions:
      contents: write
      pull-requests: write
      issues: write
    
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Extract and Create PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // GitHub Compare URLã‚’è§£æ
            function parseCompareUrl(url) {
              try {
                console.log('Parsing URL:', url);
                const urlObj = new URL(url);
                console.log('URL pathname:', urlObj.pathname);
                
                // ãƒ‘ã‚¹åã‹ã‚‰ /compare/base...head ã®éƒ¨åˆ†ã‚’æŠ½å‡º
                const pathMatch = urlObj.pathname.match(/\/compare\/(.+)\.\.\.(.+)/);
                if (!pathMatch) {
                  console.error('Path match failed for:', urlObj.pathname);
                  return null;
                }
                
                console.log('Base:', pathMatch[1], 'Head:', pathMatch[2]);
                
                return {
                  base: pathMatch[1],
                  head: pathMatch[2],
                  title: urlObj.searchParams.get('title'),
                  body: urlObj.searchParams.get('body')
                };
              } catch (error) {
                console.error('URL parsing error:', error);
                return null;
              }
            }

            // ã‚³ãƒ¡ãƒ³ãƒˆã‹ã‚‰Create PRãƒªãƒ³ã‚¯ã‚’æ¤œç´¢
            const comment = context.payload.comment.body;
            const urlMatch = comment.match(/https:\/\/github\.com\/[^\/\s]+\/[^\/\s]+\/compare\/[^\s)]+/);
            
            if (!urlMatch) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: 'âŒ Create PR link not found'
              });
              return;
            }

            // URLè§£æã¨PRä½œæˆ
            try {
              console.log('Found URL:', urlMatch[0]);
              const prInfo = parseCompareUrl(urlMatch[0]);
              console.log('Parsed info:', JSON.stringify(prInfo, null, 2));
              if (!prInfo) throw new Error('Invalid URL format');


              const newPR = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: prInfo.title || `PR: ${prInfo.head} â†’ ${prInfo.base}`,
                body: prInfo.body || `Auto-created PR from ${prInfo.head}`,
                head: prInfo.head,
                base: prInfo.base
              });

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: `âœ… PR created: ${newPR.data.html_url}`
              });

            } catch (error) {
              console.error('PR creation error:', error);
              
              // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è©³ç´°ã‚’ãƒ­ã‚°å‡ºåŠ›
              let errorMessage = error.message;
              let shouldCloseIssue = false;
              
              // GitHub API ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è§£æ
              if (error.status === 422 && error.response?.data?.errors) {
                const errors = error.response.data.errors;
                console.log('Validation errors:', JSON.stringify(errors, null, 2));
                
                // headãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®invalidã‚¨ãƒ©ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
                const headError = errors.find(err => 
                  err.resource === 'PullRequest' && 
                  err.field === 'head' && 
                  err.code === 'invalid'
                );
                
                if (headError) {
                  shouldCloseIssue = true;
                  errorMessage = `Invalid head branch: ${headError.message || 'Branch does not exist or is not accessible'}`;
                }
              }
              
              // ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆã‚’æŠ•ç¨¿
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: `âŒ Error: ${errorMessage}${shouldCloseIssue ? '\n\nğŸ”’ Auto-closing issue due to invalid branch reference.' : ''}`
              });
              
              // headãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯issueã‚’è‡ªå‹•ã‚¯ãƒ­ãƒ¼ã‚º
              if (shouldCloseIssue) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number,
                  state: 'closed',
                  state_reason: 'not_planned'
                });
                
                console.log('Issue automatically closed due to invalid head branch');
              }
            }